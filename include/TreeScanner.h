/************************************************************************
 * Copyright (C) 2017 Richard Palmer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ************************************************************************/

#pragma once
#ifndef HOUGHVOTING_TREE_SCANNER_H
#define HOUGHVOTING_TREE_SCANNER_H

#include <list>
using std::list;
#include <AdaptiveDepthPatchScanner.h>
#include <FeatureExtractor.h>
using RFeatures::FeatureExtractor;

#include "RandomTree.h"
using HoughVoting::RandomTree;


namespace HoughVoting
{

class ForestScanner;


struct Support
{
    Support( float prob, const cv::Vec2i& o) : probability( prob), offset(o) {}
    const float probability;
    const cv::Vec2i offset; // Offset to the support vote from the object centroid (vote point)
};  // end struct


class TreeScanner : private RFeatures::PatchProcessor
{
public:
    // FeatureExtractors must already have pre-processed images.
    TreeScanner( const RandomTree* tree, const vector<FeatureExtractor::Ptr>& fxs,
                 const cv::Mat_<float>& rngMap,
                 const cv::Mat_<byte>& mask,
                 bool useDepthWeighting=false);
    virtual ~TreeScanner();

    // Depth adaptively scan image and return response map (patch sizes are scaled with depth).
    const cv::Mat_<float> scaleScan( cv::Size2f realPatchSize);

    // Scan the target image using a fixed pixel patch size and return the response map.
    const cv::Mat_<float> fixedScan( cv::Size2i pixelDims);

    // Create mapping of all of the supporting votes for every pixel.
    cv::Mat_<float> createSupportMap() const;

    // Get the supporting votes for the given pixel. May be NULL if no votes exist.
    const list<Support>* getSupport( int row, int col) const;

    // Get the response map generated by a call to fixedScan or scaleScan (and returned by those functions).
    const cv::Mat_<float> getResponse() const { return _responseMap;}

private:
    const RandomTree* _tree;
    const vector<FeatureExtractor::Ptr>& _fxs;
    const cv::Mat_<float>& _rngMap;
    const cv::Mat_<byte>& _mask;
    const bool _useDepthWeighting;

    virtual void process( const cv::Point&, float, const cv::Rect&);  // RFeatures::PatchProcessor
    void addToResponseMap( const cv::Point& patchCentre, const cv::Rect& patchRect, float prob, float pdepth, const PatchSet*);

    cv::Mat_<float> _responseMap;
    cv::Mat_<list<Support>* > _supportMap;

    void resetOutputMaps( const cv::Size imgSz);

    friend class ForestScanner; // Calls addToResponseMap directly
};  // end class

}   // end namespace

#endif

